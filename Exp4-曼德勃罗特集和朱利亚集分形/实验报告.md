# 复数动力学 - Mandelbrot集与Julia集实验报告

## 一、实验目的

1. 掌握复数迭代生成分形的基本原理
2. 理解逃逸时间算法(Escape Time Algorithm)的实现方法
3. 实现Mandelbrot集和Julia集的生成与可视化
4. 分析不同参数对分形图形的影响

## 二、实验过程

### 1. 核心算法实现

**逃逸时间算法实现:**
- 输入：复数参数c、最大迭代次数max_iter
- 处理：通过迭代公式z = z² + c计算逃逸时间
- 输出：每个点的逃逸时间(迭代次数)
x = np.linspace(-2.0, 2.0, width)
    y = np.linspace(-2.0, 2.0, height)
    Re, Im = np.meshgrid(x, y)
    Z0 = Re + 1j * Im

    B = np.zeros(Z0.shape)  # 记录迭代次数
    Z = Z0.copy()  # 初始值为网格点

    for j in range(max_iter):
        mask = np.abs(Z) <= 2
        B += mask
        Z[mask] = Z[mask] ** 2 + c

    return B.T  # 转置以保持与原始代码一致的维度
**Mandelbrot集生成器:**
- 实现复数网格生成
- 记录每个c值的逃逸时间
- 返回2D逃逸时间数组
def generate_mandelbrot(width=800, height=800, max_iter=100):
    """
    生成Mandelbrot集数据(向量化版本)
    :param width: 图像宽度
    :param height: 图像高度
    :param max_iter: 最大迭代次数
    :return: Mandelbrot集数据
    """
    x = np.linspace(-2.0, 1.0, width)
    y = np.linspace(-1.5, 1.5, height)
    Re, Im = np.meshgrid(x, y)
    C = Re + 1j * Im

    B = np.zeros(C.shape)  # 记录迭代次数
    Z = np.zeros(C.shape, dtype=np.complex128)  # Z的初值为0

    for j in range(max_iter):
        mask = np.abs(Z) <= 2
        B += mask
        Z[mask] = Z[mask] ** 2 + C[mask]

    return B.T  # 转置以保持与原始代码一致的维度
**Julia集生成器:**
- 实现复数网格生成
- 记录每个z0值的逃逸时间(固定c值)
- 返回2D逃逸时间数组
def generate_julia(c, width=800, height=800, max_iter=100):
    """
    生成Julia集数据(向量化版本)
    :param c: Julia集参数
    :param width: 图像宽度
    :param height: 图像高度
    :param max_iter: 最大迭代次数
    :return: Julia集数据
    """
    x = np.linspace(-2.0, 2.0, width)
    y = np.linspace(-2.0, 2.0, height)
    Re, Im = np.meshgrid(x, y)
    Z0 = Re + 1j * Im

    B = np.zeros(Z0.shape)  # 记录迭代次数
    Z = Z0.copy()  # 初始值为网格点

    for j in range(max_iter):
        mask = np.abs(Z) <= 2
        B += mask
        Z[mask] = Z[mask] ** 2 + c

    return B.T  # 转置以保持与原始代码一致的维度
### 2. 分形实现

**Mandelbrot集参数:**
- 坐标范围：x ∈ [-2.0, 1.0], y ∈ [-1.5, 1.5]
- 最大迭代次数：100-200次
- 分辨率：800×800像素

**Julia集参数:**
- 坐标范围：x ∈ [-2.0, 2.0], y ∈ [-2.0, 2.0]
- 测试c值：-0.8+0.156j, -0.4+0.6j, 0.285+0.01j
- 最大迭代次数：100-200次
- 分辨率：800×800像素

### 3. 遇到的问题与解决

1. 计算复杂度高
问题描述
Mandelbrot 集和 Julia 集的计算通常需要对大量的复数点进行迭代运算，这会使计算复杂度变得很高，尤其是在高分辨率的情况下，计算时间会显著增加。
解决方法
优化算法：可以采用多线程或并行计算的方式来加快计算速度。例如，在 Python 中使用multiprocessing库进行多进程计算。
减少不必要的计算：可以提前对一些明显不在集合内的点进行筛选，避免对这些点进行不必要的迭代计算。
2. 数值稳定性问题
问题描述
在迭代计算过程中，复数的模可能会变得非常大，导致数值溢出或精度损失。
解决方法
设置合适的阈值：在迭代过程中，当复数的模超过某个预设的阈值时，就认为该点不在集合内，停止迭代。
使用高精度数据类型：在某些情况下，可以使用 Python 的decimal模块来进行高精度计算，避免精度损失。
3. 图像显示问题
问题描述
在将计算结果转换为图像进行显示时，可能会遇到图像显示不清晰、颜色映射不合理等问题。
解决方法
调整颜色映射：根据迭代次数合理选择颜色映射方案，例如使用渐变色来表示不同的迭代次数，使图像更加清晰和美观。
提高图像分辨率：增加图像的分辨率可以使图像更加清晰，但同时也会增加计算时间和内存占用。
4. 内存占用问题
问题描述
在处理高分辨率的图像时，需要存储大量的计算结果，这会导致内存占用过高。
解决方法
分块计算：将图像分成多个小块进行计算，计算完一个小块后及时释放该小块的内存。
使用生成器：在 Python 中，可以使用生成器来逐个生成计算结果，避免一次性存储大量数据。

## 三、结果展示

### 1. Mandelbrot集
![image](https://github.com/user-attachments/assets/14cd687e-a0e5-4e7f-ac9e-570269cc54f7)

- 迭代次数对图像细节的影响
- 自相似性特征分析

### 2. Julia集 
![image](https://github.com/user-attachments/assets/b3c3d15c-eaf1-405e-b627-0c987a0d9c06)
![image](https://github.com/user-attachments/assets/ef914cc1-d937-47c2-88fe-36be2a92196a)
![image](https://github.com/user-attachments/assets/8f20ab24-e5dc-4640-9c0b-24a71461d2f2)

- 不同c值对Julia集形态的影响
- 迭代次数与计算时间的关系

## 四、分析与思考

1. **分形特性分析**
   - Mandelbrot集与Julia集的数学关系
   - 逃逸半径的选择对结果的影响

2. **参数影响实验**
   - 不同max_iter值的效果对比
   - 分辨率与计算复杂度的关系

3. **扩展思考**
   - 如何实现平滑着色算法
   - 分形放大功能的实现思路
   - 与L系统分形的比较

4. **算法优化**
   - 向量化计算的优化效果
   - 并行计算的可能性

**注：请在每一部分补充您的实验内容、图像、分析和关键代码。**
