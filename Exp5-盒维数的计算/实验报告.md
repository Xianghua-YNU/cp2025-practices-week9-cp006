# 盒计数法估算分形维数实验报告

## 一、实验目的

1. 理解分形维数（特别是盒维数）的概念和数学原理
2. 掌握盒计数(Box Counting)算法的实现方法
3. 通过编程计算给定分形图像的维数
4. 分析不同参数对计算结果的影响

## 二、实验过程

### 1. 核心算法实现

**图像加载与二值化:**
- 使用Pillow/PIL库读取图像
- 设定阈值进行二值化处理
- 转换为NumPy数组
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

def load_and_binarize_image(image_path, threshold=128):
    """
    加载图像并转换为二值数组
    :param image_path: 图像文件路径
    :param threshold: 二值化阈值 (0-255)
    :return: 二值化的NumPy数组 (0和1)
    """
    img = Image.open(image_path).convert('L')  # 转换为灰度
    img_array = np.array(img)
    binary_image = (img_array > threshold).astype(int)
    return binary_image

def box_count(binary_image, box_sizes):
**盒计数算法实现:**
```python
 :param binary_image: 二值图像数组
    :param box_sizes: 盒子尺寸列表
    :return: 字典 {box_size: count}
    """
    height, width = binary_image.shape
    counts = {}
    
    for box_size in box_sizes:
        # 计算网格行列数
        rows = height // box_size
        cols = width // box_size
        
        count = 0
        
        # 遍历所有盒子
        for i in range(rows):
            for j in range(cols):
                # 获取当前盒子区域
                box = binary_image[i*box_size:(i+1)*box_size, 
                                  j*box_size:(j+1)*box_size]
                
                # 检查盒子是否包含前景像素
                if np.any(box == 1):
                    count += 1
        
        counts[box_size] = count
    
    return counts

def calculate_fractal_dimension(binary_image, min_box_size=1, max_box_size=None, num_sizes=10):
    """
    计算分形维数
    :param binary_image: 二值图像数组
    :param min_box_size: 最小盒子尺寸
    :param max_box_size: 最大盒子尺寸
    :param num_sizes: 盒子尺寸数量
    :return: 盒维数, 拟合结果
    """
    if max_box_size is None:
        max_box_size = min(binary_image.shape) // 2
    
    # 生成等比数列的盒子尺寸
    box_sizes = np.logspace(np.log2(min_box_size), np.log2(max_box_size), 
                           num=num_sizes, base=2).astype(int)
    box_sizes = np.unique(box_sizes)  # 去除重复值
    
    # 执行盒计数
    counts = box_count(binary_image, box_sizes)
数据处理与线性回归:

- 计算log(ε)和log(N(ε))
- 使用numpy.polyfit进行线性拟合
- 计算分形维数 D = -slope
epsilons = np.array(list(counts.keys()))
    N_epsilons = np.array(list
### 2. 实验参数
[插入测试图像]


### 3. 遇到的问题与解决
(请在此描述实现过程中遇到的问题及解决方法)

## 三、结果展示
### 1. 盒计数结果
![image](https://github.com/user-attachments/assets/42bc3133-5f1e-4cc5-b3f8-a34766a0cad2)


关键数据:

- 盒子尺寸(ε): [列表]
- 盒子计数(N(ε)): [列表]
- 拟合斜率: [数值]
- 计算得分形维数D: [数值]
### 2. 与理论值比较
- 理论分形维数: [填写理论值]
- 计算误差分析: [填写误差百分比]
## 四、分析与思考
1. 算法准确性分析
   
   - 盒子尺寸选择对结果的影响
   - 图像分辨率对计算精度的影响
2. 误差来源分析
   
   - 边界处理的影响
   - 线性拟合的合理性评估
3. 扩展思考
   
   - 如何改进算法提高计算精度
   - 三维分形维数的计算方法
   - 与其他维数计算方法的比较
4. 算法优化
   
   - 计算效率优化方案
   - 并行计算的可能性

**注：请在每一部分补充您的实验内容、图像、分析和关键代码。**
